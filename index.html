<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Shooter Game</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>SHOOTER JS</h1>
        <p>移動: 矢印キー | 攻撃: スペースキー</p>
        <h2 id="scoreBoard">SCORE: 0</h2>
    </div>
    <canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');

    // ゲームの状態
    let score = 0;
    let gameOver = false;
    let frameCount = 0;

    // キー入力管理
    const keys = {
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
        " ": false
    };

    document.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
        // ゲームオーバー時のリスタート
        if (gameOver && e.key === " ") location.reload();
    });

    document.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
    });

    // プレイヤー（自機）クラス
    class Player {
        constructor() {
            this.width = 40;
            this.height = 20;
            this.x = 50;
            this.y = canvas.height / 2 - this.height / 2;
            this.speed = 5;
            this.color = '#00ffcc';
            this.bulletTimer = 0;
        }

        update() {
            // 移動処理
            if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
            if (keys.ArrowDown && this.y + this.height < canvas.height) this.y += this.speed;
            if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
            if (keys.ArrowRight && this.x + this.width < canvas.width) this.x += this.speed;

            // 発射処理 (連射速度制限)
            if (keys[" "]) {
                if (this.bulletTimer <= 0) {
                    bullets.push(new Bullet(this.x + this.width, this.y + this.height / 2));
                    this.bulletTimer = 10; // 連射間隔
                }
            }
            if (this.bulletTimer > 0) this.bulletTimer--;
        }

        draw() {
            ctx.fillStyle = this.color;
            // 自機を三角形っぽく描画
            ctx.beginPath();
            ctx.moveTo(this.x + this.width, this.y + this.height / 2);
            ctx.lineTo(this.x, this.y);
            ctx.lineTo(this.x + 10, this.y + this.height / 2);
            ctx.lineTo(this.x, this.y + this.height);
            ctx.closePath();
            ctx.fill();
        }
    }

    // 弾クラス
    class Bullet {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 10;
            this.height = 4;
            this.speed = 10;
            this.color = '#ffff00';
            this.markedForDeletion = false;
        }

        update() {
            this.x += this.speed;
            if (this.x > canvas.width) this.markedForDeletion = true;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y - this.height/2, this.width, this.height);
        }
    }

    // 敵クラス
    class Enemy {
        constructor() {
            this.width = 30;
            this.height = 30;
            this.x = canvas.width;
            this.y = Math.random() * (canvas.height - this.height);
            this.speed = Math.random() * 2 + 2; // 2〜4のランダム速度
            this.color = '#ff4444';
            this.markedForDeletion = false;
        }

        update() {
            this.x -= this.speed;
            if (this.x + this.width < 0) this.markedForDeletion = true;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            // 敵のデザイン（少し目をつける）
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x + 5, this.y + 5, 5, 5);
        }
    }

    // 背景の星クラス
    class Star {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 2;
            this.speed = Math.random() * 3 + 0.5;
        }
        update() {
            this.x -= this.speed;
            if (this.x < 0) {
                this.x = canvas.width;
                this.y = Math.random() * canvas.height;
            }
        }
        draw() {
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    // インスタンス管理
    const player = new Player();
    let bullets = [];
    let enemies = [];
    let stars = [];

    // 星の初期化
    for(let i=0; i<50; i++) stars.push(new Star());

    // 衝突判定関数
    function checkCollision(rect1, rect2) {
        return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
        );
    }

    // メインループ
    function animate() {
        if (gameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '40px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
            ctx.font = '20px Courier New';
            ctx.fillText("Press SPACE to Restart", canvas.width/2, canvas.height/2 + 40);
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 背景（星）
        stars.forEach(star => {
            star.update();
            star.draw();
        });

        // プレイヤー
        player.update();
        player.draw();

        // 弾の処理
        bullets.forEach((bullet, index) => {
            bullet.update();
            bullet.draw();
            if (bullet.markedForDeletion) bullets.splice(index, 1);
        });

        // 敵の出現と処理
        if (frameCount % 60 === 0) { // 約1秒ごとに敵出現
            enemies.push(new Enemy());
        }

        enemies.forEach((enemy, eIndex) => {
            enemy.update();
            enemy.draw();

            // 衝突判定：弾 vs 敵
            bullets.forEach((bullet, bIndex) => {
                if (checkCollision(bullet, enemy)) {
                    score += 100;
                    scoreBoard.innerText = "SCORE: " + score;
                    enemy.markedForDeletion = true;
                    bullet.markedForDeletion = true;
                }
            });

            // 衝突判定：プレイヤー vs 敵
            if (checkCollision(player, enemy)) {
                gameOver = true;
            }

            if (enemy.markedForDeletion) enemies.splice(eIndex, 1);
        });

        frameCount++;
        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>
